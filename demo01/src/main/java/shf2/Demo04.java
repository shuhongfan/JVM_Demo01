package shf2;

/**
 * JVM在进行GC时，并不是对这三个区域统一回收。大部分时候，回收都是新生代~
 * 新生代
 * 幸存区（form，to）
 * 老年区
 *
 * GC两种类： 轻GC（普通的GC）、重GC（全局GC）
 *
 * JVM的内存模型和分区~详细到每个区放什么？
 *  方法区：主要是存储类信息，常量池（static常量和static变量），编译后的代码（字节码）等数据
 *  堆：初始化的对象，成员变量（那种非static的变量），所有的对象实例和数据都要再堆上分配
 *  栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，
 *      局部变量表存放的是8大基础类型加上一个应用类型，所以还是一个指向地址的指针
 *  本地方法栈：主要Native方法服务
 *  程序计数器：记录当前线程指向的行号
 *
 *  堆里面的分区有哪些？  Eden，from，to，老年区
 *    堆里面分为新生代和老年代（java8取消了永久代，采用了Metaspace），新生代包含Eden+Survivor区，
 *    survivor区里面分为from和to区，内存回收时，如果用的是复制算法，从from复制到to，当经历一次或多次
 *    GC后，存活下来的对象会被移动到老年区，当JVM内存不够用的时候，会触发Full GC，清理JVM老年区
 *
 *    当新生区满了之后会触发YGC，先把存活的对象放到其中一个Survice区，然后进行垃圾清理。
 *    因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把Eden进行完全的清理，然后整理内存。
 *    那么下次GC的时候，就会使用下一个Survive，这样循环使用。如果有特别大的对象，新生代放不下，
 *    就会使用老年代的担保，直接放到老年代里面。因为JVM认为，一般大对象的存活时间比一般比较久远。
 *
 *
 *   GC的算法有哪些？标记清除法、标记整理，复制算法，引用计数器
 *
 *    复制算法
 *      谁空谁是to
 *      每次GC 都会将Eden或的对象移到幸存区中；一旦Eden区被GC后，就会是空的！
 *      当一个对象经历了15次GC，都还没有死
 *      -XX: -XX:MaxTenuringThreshold=9999 设置进入老年代的时间
 *
 *      好处： 没有内存的碎片~
 *      坏处： 浪费了内存空间~： 多了一半空间永远是空to。假设对象100%存活（极端情况）
 *
 *      复制算法最佳使用场景：对象存活度较低的时候
 *
 *
 *   标记清除算法
 *      扫描这些对象： 对不用清除对象进行标记
 *      清除： 对没有标记的对象，进行清除
 *
 *
 *      优点：不需要额外的空间！
 *      缺点： 两次扫描，严重浪费时间，会产生内存碎片。
 *
 *   标记清除压缩算法
 *      压缩： 防止内存碎片产生，再次扫描，向后移动存活的对象，多了一个移动成本
 *
 *  总结
 *      内存效率：  复制算法-->标记清除算法--->标记压缩算法(时间复杂度)
 *      内存整齐度：  复制算法=标记压缩算法--->标记清除算法
 *      内存利用率： 标记压缩算法=标记清除算法-->复制算法
 *
 *   难道没有最优算法吗？
 *   答案：没有，没有最好的算法，只有最合适的算法---->GC：分代收集算法
 *
 *   年轻代：
 *      存活率低
 *      复制算法
 *
 *   老年代：
 *      区域大：存活率高
 *      标记清除（内存碎片不是太多）+标记压缩混合 实现
 */
public class Demo04 {

}

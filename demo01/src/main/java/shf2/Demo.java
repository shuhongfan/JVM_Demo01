package shf2;

import org.junit.Test;

public class Demo {
    @Test
    public void test1() {
        new Thread(()->{

        },"my thread name").start();
    }

    /**
     * native: 凡事带了native 关键字的，说明java的作用范围达不到了，回去调用底层C语言的库！
     * 会进入本地方法栈
     * 调用本地方法本地接口 JNI
     * JNI作用：扩展Java的使用，融合不同的编程语言为Java所用！ 最初：c、c++
     * java诞生的时候 c、c++横行，想要立足，必须要有调用c、c++的程序
     * 它在内存区域中专门开辟了一块标记区域：Native Method Stack，登记native方法
     * 在最终执行的时候，加载本地方法库中的方法通过JNI
     *
     * Java程序驱动打印机，管理系统，掌握即可，在企业级应用中较为少见！
     */
//    private native void start0();

//    调用其他接口： Socket.WebService..http

    /**
     * PC寄存器
     * 程序计数器：Program Counter Register
     * 每个线程都有一个程序计数器，是线程私有的，就是一个指针，执行方法区中的方法字节码（用来存储指向像
     * 一条指令节点地址，也即将要执行的指定代码），在执行引擎读取下一条指令，是一个非常小的内存空间，
     * 几乎可以忽略不计
     */

    /**
     * 方法区： Method Area方法区  static、final、Class、常量池
     *  方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，
     *  简单说，所有定义的方法的信息都保存在该区域，此属于共享区间：
     *  静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池在方法区中，
     *  但是 实例变量存在堆内存中和方法区无关
     */

    /**
     * 栈： 先进后出、后进先出、桶
     * 队列：先进先出（FIFO：first input first output）
     *
     * 喝多了吐就是栈，吃多拉就是队列
     *
     * 为什么main()先执行，最后结束~
     * 栈：栈内存，主管程序的运行，声明周期和线程同步
     * 线程结束，栈内存也就是释放，对于栈来说，不存在垃圾回收的问题
     * 一旦线程结束，栈就over
     * 栈： 8大基本类型+对象引用+实例的方法
     *
     * 栈运行原理：栈帧
     * 栈满了  StackOverFlow
     */

    /**
     * 堆
     * heap，一个jvm只有一个堆内存，堆内存的大小是可以调节的
     * 类加载器读取了类文件后，一般会把什么东西放到堆中？
     * 类、方法、常量、变量~，保存我们所有引用类型的真实对象；
     * 堆内存中还要细分为三个区域：
     *          新生区（伊甸园区Eden Space）Young/New
     *          养老区  old
     *          永生区 Perm
     *
     *  GC垃圾回收，主要是在伊甸园区和养老区~
     *  假设内存满了，OOM，堆内存不够！ java heap space
     *  在JDK8以后，永久存储区改了一个名字（元空间）
     *
     *
     *  新生区：诞生和成长的地方，甚至死亡
     *  伊甸园，所有的对象都是在 伊甸园区 new出来的！
     *  幸存者区 （0、1）
     *  真理：经过研究，99%的对象都是临时对象
     *
     * 永久区： 这个区域是常驻内存的。
     * 用来存放JDK自身携带的Class对象。
     * Interface元数据，存储的是java运行时的一些环境或类信息~，
     * 这个区域不存在垃圾回收！ 关闭VM虚拟机就会释放这个区域的内存~
     *
     * 一个启动类，加载了大量的第三方jar包。Tomcat部署了太多的应用，大量动态生成的反射类。
     * jdk1.6之前：永生代，常量池在方法区
     * jdk1.7： 永生代，但是慢慢退化了，去永久代，常量池在堆中
     * jdk1.8之后：无永久代，常量池在元空间
     */
}
